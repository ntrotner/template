/*
 * Swagger - OpenAPI 3.0
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Contact: nikita@ttnr.me
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"net/http"
	models "template_backend/open-api/models"

	"github.com/go-playground/validator/v10"
	"github.com/rs/zerolog/log"
)

// ErrorHandler defines the required method for handling error. You may implement it and inject this into a controller if
// you would like errors to be handled differently from the DefaultErrorHandler
type ErrorHandler func(w http.ResponseWriter, r *http.Request, err error, result *models.ImplResponse)

// DefaultErrorHandler defines the default logic on how to handle errors from the controller. Any errors from parsing
// request params will return a StatusBadRequest. Otherwise, the error code originating from the servicer will be used.
func DefaultErrorHandler(w http.ResponseWriter, r *http.Request, err error, result *models.ImplResponse) {
	if _, ok := err.(*models.ParsingError); ok {
		// Handle parsing errors
		EncodeJSONResponse(err.Error(), func(i int) *int { return &i }(http.StatusBadRequest), w)
	} else if _, ok := err.(*models.RequiredError); ok {
		// Handle missing required errors
		EncodeJSONResponse(err.Error(), func(i int) *int { return &i }(http.StatusUnprocessableEntity), w)
	} else if validationErrors, ok := err.(validator.ValidationErrors); ok {
		errorMessages := models.Error{ErrorMessages: []models.Message{}}
		for _, e := range validationErrors {
			errorMessages.ErrorMessages = append(errorMessages.ErrorMessages, models.Message{Code: "200", Message: e.Field() + ": Validation Failed"})
		}
		EncodeJSONResponse(errorMessages, &models.DefaultValidatorError, w)
		log.Error().Str("request", r.RequestURI).Msg(err.Error())
	} else {
		// Handle all other errors
		EncodeJSONResponse(err.Error(), &result.Code, w)
	}
}
