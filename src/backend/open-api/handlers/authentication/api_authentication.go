/*
 * Swagger - OpenAPI 3.0
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Contact: nikita@ttnr.me
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"strings"
	"template_backend/core/config"
	models "template_backend/open-api/models"
	runtime "template_backend/open-api/runtime"
)

// AuthenticationAPIRouter defines the required methods for binding the api requests to a responses for the AuthenticationAPI
// The AuthenticationAPIRouter implementation should parse necessary information from the http request,
// pass the data to a AuthenticationAPIServicer to perform the required actions, then write the service results to the http response.
type AuthenticationAPIRouter interface {
	LoginPost(http.ResponseWriter, *http.Request)
	LogoutPost(http.ResponseWriter, *http.Request)
	RefreshTokenPost(http.ResponseWriter, *http.Request)
	RegisterPost(http.ResponseWriter, *http.Request)
}

// AuthenticationAPIServicer defines the api actions for the AuthenticationAPI service
// This interface intended to stay up to date with the openapi yaml used to generate it,
// while the service implementation can be ignored with the .openapi-generator-ignore file
// and updated with the logic required for the API.
type AuthenticationAPIServicer interface {
	LoginPost(context.Context, models.UserLogin, http.ResponseWriter) (models.ImplResponse, error)
	LogoutPost(context.Context, *http.Request) (models.ImplResponse, error)
	RefreshTokenPost(context.Context, http.ResponseWriter, *http.Request) (models.ImplResponse, error)
	RegisterPost(context.Context, models.UserRegistration, http.ResponseWriter) (models.ImplResponse, error)
}

// AuthenticationAPIController binds http requests to an api service and writes the service results to the http response
type AuthenticationAPIController struct {
	service      AuthenticationAPIServicer
	errorHandler runtime.ErrorHandler
}

// AuthenticationAPIOption for how the controller is set up.
type AuthenticationAPIOption func(*AuthenticationAPIController)

// WithAuthenticationAPIErrorHandler inject ErrorHandler into controller
func WithAuthenticationAPIErrorHandler(h runtime.ErrorHandler) AuthenticationAPIOption {
	return func(c *AuthenticationAPIController) {
		c.errorHandler = h
	}
}

// NewAuthenticationAPIController creates a default api controller
func NewAuthenticationAPIController(s AuthenticationAPIServicer, opts ...AuthenticationAPIOption) runtime.Router {
	controller := &AuthenticationAPIController{
		service:      s,
		errorHandler: runtime.DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the AuthenticationAPIController
func (c *AuthenticationAPIController) Routes() runtime.Routes {
	return runtime.Routes{
		"LoginPost": runtime.Route{
			Method:      strings.ToUpper("Post"),
			Pattern:     "/login",
			HandlerFunc: c.LoginPost,
		},
		"LogoutPost": runtime.Route{
			Method:      strings.ToUpper("Post"),
			Pattern:     "/logout",
			HandlerFunc: c.LogoutPost,
		},
		"RefreshTokenPost": runtime.Route{
			Method:      strings.ToUpper("Post"),
			Pattern:     "/refresh-token",
			HandlerFunc: c.RefreshTokenPost,
		},
		"RegisterPost": runtime.Route{
			Method:      strings.ToUpper("Post"),
			Pattern:     "/register",
			HandlerFunc: c.RegisterPost,
		},
	}
}

// LoginPost - User login
func (c *AuthenticationAPIController) LoginPost(w http.ResponseWriter, r *http.Request) {
	userLoginParam := models.UserLogin{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&userLoginParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &models.ParsingError{Err: err}, nil)
		return
	}
	if err := models.AssertUserLoginRequired(userLoginParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := models.AssertUserLoginConstraints(userLoginParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.LoginPost(r.Context(), userLoginParam, w)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	runtime.EncodeJSONResponse(result.Body, &result.Code, w)
}

// LogoutPost - User logout
func (c *AuthenticationAPIController) LogoutPost(w http.ResponseWriter, r *http.Request) {
	result, err := c.service.LogoutPost(r.Context(), r)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	runtime.EncodeJSONResponse(result.Body, &result.Code, w)
}

// RefreshTokenPost - Refresh authentication token
func (c *AuthenticationAPIController) RefreshTokenPost(w http.ResponseWriter, r *http.Request) {
	result, err := c.service.RefreshTokenPost(r.Context(), w, r)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	runtime.EncodeJSONResponse(result.Body, &result.Code, w)
}

// RegisterPost - Register a new user
func (c *AuthenticationAPIController) RegisterPost(w http.ResponseWriter, r *http.Request) {
	if !config.GlobalConfig.Shared.App.AdminOnly {
		c.errorHandler(w, r, errors.New("Forbidden"), nil)
		return
	}

	userRegistrationParam := models.UserRegistration{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&userRegistrationParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &models.ParsingError{Err: err}, nil)
		return
	}
	if err := models.AssertUserRegistrationRequired(userRegistrationParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := models.AssertUserRegistrationConstraints(userRegistrationParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.RegisterPost(r.Context(), userRegistrationParam, w)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	runtime.EncodeJSONResponse(result.Body, &result.Code, w)
}
